---
date: 2019-10-10
layout: default

title: nio






---

## java nio

### bytebuffer

### socket channel

### selector

```java
// 1. 获取数据源 和 目标传输地的输入输出流（此处以数据源 = 文件为例）
    FileInputStream fin = new FileInputStream(infile);
    FileOutputStream fout = new FileOutputStream(outfile);

    // 2. 获取数据源的输入输出通道
    FileChannel fcin = fin.getChannel();
    FileChannel fcout = fout.getChannel();

    // 3. 创建 缓冲区 对象：Buffer（共有2种方法）
     // 方法1：使用allocate()静态方法
     ByteBuffer buff = ByteBuffer.allocate(256);
     // 上述方法创建1个容量为256字节的ByteBuffer
     // 注：若发现创建的缓冲区容量太小，则重新创建一个大小合适的缓冲区

    // 方法2：通过包装一个已有的数组来创建
     // 注：通过包装的方法创建的缓冲区保留了被包装数组内保存的数据
     ByteBuffer buff = ByteBuffer.wrap(byteArray);

     // 额外：若需将1个字符串存入ByteBuffer，则如下
     String sendString="你好,服务器. ";
     ByteBuffer sendBuff = ByteBuffer.wrap(sendString.getBytes("UTF-16"));

    // 4. 从通道读取数据 & 写入到缓冲区
    // 注：若 以读取到该通道数据的末尾，则返回-1
    fcin.read(buff);

    // 5. 传出数据准备：将缓存区的写模式 转换->> 读模式
    buff.flip();

    // 6. 从 Buffer 中读取数据 & 传出数据到通道
    fcout.write(buff);

    // 7. 重置缓冲区
    // 目的：重用现在的缓冲区,即 不必为了每次读写都创建新的缓冲区，在再次读取之前要重置缓冲区
    // 注：不会改变缓冲区的数据，只是重置缓冲区的主要索引值
    buff.clear();

```

```java
public class ServerSocketChannelTest {
 private static byte[] data = new byte[255];
 
 public static void main(String[] args) throws IOException {
  for (int i = 0; i < data.length; i++) {
   data[i] = (byte) i;
  }
  //新建NIO通道
  ServerSocketChannel server = ServerSocketChannel.open();
  //使通道为非阻塞
  server.configureBlocking(false);
  //创建基于NIO通道的socket连接
  ServerSocket ss = server.socket();
  //新建socket通道的端口
  ss.bind(new InetSocketAddress(9000));
  //将NIO通道绑定到选择器
  Selector selector = Selector.open();
  server.register(selector, SelectionKey.OP_ACCEPT);
 
  while (true) {
   //获取通道内是否有选择器的关心事件
   int num = selector.select();
   //如果小于1,停止此次循环,进行下一个循环
   if (num < 1) {
    continue;
   }
   //获取通道内关心事件的集合
   Set selectedKeys = selector.selectedKeys();
   Iterator iterator = selectedKeys.iterator();
   while (iterator.hasNext()) {
    SelectionKey key = (SelectionKey) iterator.next();
    //移走此次事件
    iterator.remove();
    
    if (key.isAcceptable()) {
     //获取对应的SocketChannel
     SocketChannel client = server.accept();
     System.out.println("Accepted connection from " + client);
     //使此通道为非阻塞
     client.configureBlocking(false);
     //将数组data的大小定义为ByteBuffer缓冲区的大小
     ByteBuffer source = ByteBuffer.wrap(data);
     
     //在此通道上注册事件
     SelectionKey key2 = client.register(selector,
       SelectionKey.OP_WRITE);
     //通道执行事件
     key2.attach(source);
    } else if (key.isWritable()) {
     //获取此通道的SocketChannel
     SocketChannel client = (SocketChannel) key.channel();
     ByteBuffer output = (ByteBuffer) key.attachment();
     //如果缓存区没了,重置一下
     if (!output.hasRemaining()) {
      output.rewind();
     }
     //在此通道内写东西
     client.write(output);
    }
    key.channel().close();
   }
 
  }
 
 }
}


public class SocketChannelTest {
 public static void main(String[] args) throws Exception {
  //建立到服务端的链接
  SocketAddress address = new InetSocketAddress("127.0.0.1", 9000);
  SocketChannel client = SocketChannel.open(address);
  //创建静态的缓冲区
  ByteBuffer buffer = ByteBuffer.allocate(255);
 
  //读取数据,到buffer中
  client.read(buffer);
  //将position重新置为0
  buffer.clear();
  //输出缓冲区的数据
  for (int i = 0; i < buffer.array().length; i++) {
   System.out.println(buffer.array()[i]);
  }
 }
}
```

#### nio byteBuffer

容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。初始设定后不能更改。
上界（Limit）：缓冲区中第一个不能被读或者写的元素位置。或者说，缓冲区内现存元素的上界。
位置（Position）：缓冲区内下一个将要被读或写的元素位置。在进行读写缓冲区时，位置会自动更新。
标记（Mark）：一个备忘位置。初始时为“未定义”，调用mark时mark=positon，调用reset时position=mark。
这四个属性总是满足如下关系：

```text
mark<=position<=limit<=capacity
```

### reference

https://www.jianshu.com/p/d30893c4d6bb